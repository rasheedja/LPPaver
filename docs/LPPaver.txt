-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/rasheedja/LPPaver#readme</a>
@package LPPaver
@version 0.0.2.0


-- | Module defining the <a>Constraint</a> data type.
module LPPaver.Constraint.Type

-- | The <a>Constraint</a> data type is used to represent non-strict
--   inequalities. The LHS is a list of <a>String</a> variables along with
--   their <a>Rational</a> coefficients. The RHS is a <a>Rational</a>
--   number.
data Constraint
GEQ :: [(String, Rational)] -> Rational -> Constraint
LEQ :: [(String, Rational)] -> Rational -> Constraint


-- | Module defining useful utility functions for the <a>Constraint</a>
--   data type.
module LPPaver.Constraint.Util

-- | Get the LHS of a <a>Constraint</a>
constraintLeftSide :: Constraint -> [(String, Rational)]

-- | Get the LHS of a <a>Constraint</a>
constraintRightSide :: Constraint -> Rational

-- | Get a list of all variables in a list of <a>Constraint</a>s
constraintVars :: [Constraint] -> [String]

-- | Convert a list of <a>Constraint</a>s into a list of
--   <a>PolyConstraint</a>s. The function returns a pair with the first
--   item being a list of <a>PolyConstraint</a>s and the second item being
--   a mapping of <a>String</a> variables (from <a>Constraint</a>s) to
--   <a>Integer</a> variables (for <a>PolyConstraint</a>s).
constraintsToSimplexConstraints :: [Constraint] -> ([PolyConstraint], Map String Integer)


-- | Module defining useful utility functions for the LPPaver.Decide
--   modules
module LPPaver.Decide.Util

-- | Dummy trace function
trace :: p -> p -> p

-- | Calculate the range of some <a>E</a> expression over the given
--   <a>VarMap</a> with the given <a>Precision</a> using <a>apply</a>.
applyExpression :: E -> VarMap -> Precision -> CN MPBall

-- | Calculate the gradient of some <a>E</a> expression over the given
--   <a>VarMap</a> with the given <a>Precision</a> using <a>gradient</a>.
gradientExpression :: E -> VarMap -> Precision -> Vector (CN MPBall)

-- | Run <a>applyExpression</a> on each <a>E</a> in a given list
applyExpressionList :: [E] -> VarMap -> Precision -> [CN MPBall]

-- | Run <a>gradientExpression</a> on each <a>E</a> in a given list
gradientExpressionList :: [E] -> VarMap -> Precision -> [Vector (CN MPBall)]

-- | Run <a>applyExpressionList</a> on each '[E.E]' in a given list
applyExpressionDoubleList :: [[E]] -> VarMap -> Precision -> [[CN MPBall]]

-- | Run <a>gradientExpressionList</a> on each '[E.E]' in a given list
gradientExpressionDoubleList :: [[E]] -> VarMap -> Precision -> [[Vector (CN MPBall)]]

-- | Run <a>applyExpressionDoubleList</a> on an [[<a>ESafe</a>]]
applyESafeDoubleList :: [[ESafe]] -> VarMap -> Precision -> [[CN MPBall]]

-- | Run <a>gradientExpressionDoubleList</a> on an [[<a>ESafe</a>]]
gradientESafeDoubleList :: [[ESafe]] -> VarMap -> Precision -> [[Vector (CN MPBall)]]

-- | Evaluate an <a>F</a> over some <a>VarMap</a> with a given
--   <a>Precision</a> using <a>applyExpression</a>
checkFWithApply :: F -> VarMap -> Precision -> CN Kleenean

-- | Filter out expressions in a list which are certainly false. If an
--   expression cannot be evaluated, do not filter it out.
filterOutFalseExpressions :: [((ESafe, BoxFun), CN MPBall)] -> [((ESafe, BoxFun), CN MPBall)]

-- | Filter out expressions in a list which are certainly true. If an
--   expression cannot be evaluated, do not filter it out.
filterOutTrueExpressions :: [((ESafe, BoxFun), CN MPBall)] -> [((ESafe, BoxFun), CN MPBall)]

-- | Returns true if any of the ranges of the given Expression have been
--   evaluated to be greater than or equal to zero.
decideRangesGEZero :: [((E, BoxFun), CN MPBall)] -> Bool

-- | The mean of a list of 'CN Dyadic' numbers.
mean :: [CN Dyadic] -> CN Rational

-- | Safely find the maximum of a list of ordered elements, avoiding
--   exceptions by ignoring anything with errors
safeMaximum :: (HasOrderAsymmetric a a, CanTestCertainly (OrderCompareType a a), CanTestErrorsPresent a) => a -> [a] -> a

-- | Safely find the maximum centre of a list of <a>BoxFun</a>s over a
--   given <a>Box</a>, avoiding exceptions by ignoring anything with errors
safeMaximumCentre :: [BoxFun] -> Box -> Maybe (CN Dyadic) -> Maybe (CN Dyadic)

-- | Safely find the maximum minimum of a list of <a>BoxFun</a>s over a
--   given <a>Box</a>, avoiding exceptions by ignoring anything with errors
safeMaximumMinimum :: [BoxFun] -> Box -> Maybe (CN MPBall) -> Maybe (CN MPBall)

-- | Safely find the maximum maximum of a list of <a>BoxFun</a>s over a
--   given <a>Box</a>, avoiding exceptions by ignoring anything with errors
safeMaximumMaximum :: [BoxFun] -> Box -> Maybe (CN MPBall) -> Maybe (CN MPBall)

-- | Bisect the widest interval in a <a>VarMap</a>
bisectWidestInterval :: VarMap -> (VarMap, VarMap)

-- | Bisect the widest interval in a <a>TypedVarMap</a>
bisectWidestTypedInterval :: TypedVarMap -> (TypedVarMap, TypedVarMap)

-- | Ensures that the first varMap is within the second varMap If it is,
--   returns the first varMap. If it isn't modifies the varMap so that the
--   returned varMap is within the second varMap Both varmaps must have the
--   same number of vars in the same order (order of vars not checked)
ensureVarMapWithinVarMap :: VarMap -> VarMap -> VarMap

-- | Version of <a>computeCornerValuesAndDerivatives</a> that returns
--   Nothing if a calculation contains an error
safelyComputeCornerValuesAndDerivatives :: [((ESafe, BoxFun), CN MPBall)] -> Box -> Maybe [(CN MPBall, CN MPBall, Vector (CN MPBall))]

-- | Return the value of the given <a>ESafe</a> expression/<a>BoxFun</a> at
--   the extreme left corner and the extreme right corner as well as
--   partial derivatives over the given <a>Box</a>. Extreme corners are
--   defined as the minimum<i>maximum of every interval in a <a>Box</a> for
--   the left</i>right extreme corners respectively.
computeCornerValuesAndDerivatives :: [((ESafe, BoxFun), CN MPBall)] -> Box -> [(CN MPBall, CN MPBall, Vector (CN MPBall))]

-- | Decide if the ranges of a conjunction of <a>ESafe</a> expressions is
--   false in a standard manner A range with an error is treated as false.
decideConjunctionRangesFalse :: [((ESafe, BoxFun), CN MPBall)] -> Bool

-- | Decide if the ranges of a conjunction of <a>ESafe</a> expressions is
--   true in a standard manner A range with an error is treated as false.
decideConjunctionRangesTrue :: [((ESafe, BoxFun), CN MPBall)] -> Bool

-- | Decide if the ranges of a disjunction of <a>ESafe</a> expressions is
--   true in a standard manner A range with an error is treated as false.
decideDisjunctionRangesTrue :: [((ESafe, BoxFun), CN MPBall)] -> Bool

-- | Decide if the ranges of a disjunction of <a>ESafe</a> expressions is
--   false in a standard manner A range with an error is treated as false.
decideDisjunctionRangesFalse :: [((ESafe, BoxFun), CN MPBall)] -> Bool

-- | Evaluate the range of each <a>ESafe</a> expression in a disjunction
--   and check if the disjunction is false in a standard manner.
decideDisjunctionFalse :: [(ESafe, BoxFun)] -> TypedVarMap -> Precision -> Bool

-- | Evaluate the range of each <a>ESafe</a> expression in a CNF and check
--   if the CNF is false in a standard manner.
decideCNFFalse :: [[(ESafe, BoxFun)]] -> TypedVarMap -> Precision -> Bool

-- | Evaluate the range of each <a>ESafe</a> expression in a conjunction
--   and check if the conjunction is true in a standard manner.
decideConjunctionTrue :: [(ESafe, BoxFun)] -> TypedVarMap -> Precision -> Bool

-- | Check the results of a disjunction in a standard manner
checkDisjunctionResults :: [(Maybe Bool, Maybe potentialModel)] -> Maybe potentialModel -> (Maybe Bool, Maybe potentialModel)

-- | Check the results of a conjunction in a standard manner
checkConjunctionResults :: [(Maybe Bool, Maybe potentialModel)] -> Maybe potentialModel -> (Maybe Bool, Maybe potentialModel)

-- | Substitute all variable-defining equalities in a given conjunction.
--   Simplify the conjunction after substituting all variable-defining
--   equalities.
substituteConjunctionEqualities :: [ESafe] -> [ESafe]


-- | Module defining linearisations for conjunctions of <a>ESafe</a> terms.
module LPPaver.Decide.Linearisation

-- | Remove unsat areas from a conjunction arising from a DNF by weakening
--   the conjunction using
--   <a>createConstraintsToRemoveConjunctionUnsatArea</a>. The resulting
--   linear system is solved and optimised by the two-phase simplex method.
--   If the linear system is infeasible, the entire conjunction was
--   unsatisfiable.
removeConjunctionUnsatAreaWithSimplex :: [(CN MPBall, CN MPBall, Box)] -> VarMap -> (Maybe Bool, Maybe VarMap)

-- | Find a satisfiable point from a conjunction arising from a DNF by
--   strengthening the conjunction using
--   <a>createConstraintsToFindSatSolution</a>. The resulting linear system
--   is solved by the first phase of the two-phase simplex method.
findConjunctionSatAreaWithSimplex :: [(CN MPBall, CN MPBall, Box)] -> VarMap -> Bool -> Maybe VarMap

-- | Linearisations that weaken a conjunction of terms over some box.
createConstraintsToRemoveConjunctionUnsatArea :: [(CN MPBall, CN MPBall, Box)] -> VarMap -> [Constraint]

-- | Linearisations that strengthen a conjunction of terms over some box.
createConstraintsToFindSatSolution :: [(CN MPBall, CN MPBall, Box)] -> VarMap -> Bool -> [Constraint]


-- | Module defining algorithms that can decide DNFs of <a>ESafe</a> terms.
module LPPaver.Decide.Algorithm

-- | Start initial call to <a>decideConjunctionBestFirst</a> for some
--   conjunction in a DNF.
setupBestFirstCheckDNF :: [(ESafe, BoxFun)] -> TypedVarMap -> Integer -> Rational -> Precision -> (Maybe Bool, Maybe TypedVarMap)

-- | Check a DNF of <a>ESafe</a> terms using a depth-first branch-and-prune
--   algorithm which tends to perform well when the problem is
--   unsatisfiable.
checkEDNFDepthFirstWithSimplex :: [[ESafe]] -> TypedVarMap -> Integer -> Rational -> Precision -> (Maybe Bool, Maybe TypedVarMap)

-- | Check a DNF of <a>ESafe</a> terms using a best-first branch-and-prune
--   algorithm which tends to perform well when the problem is satisfiable.
checkEDNFBestFirstWithSimplexCE :: [[ESafe]] -> TypedVarMap -> Integer -> Rational -> Precision -> (Maybe Bool, Maybe TypedVarMap)

-- | Attempt to decide a conjunction over some given box using basic
--   interval evaluation via <a>apply</a>
decideConjunctionWithApply :: [(ESafe, BoxFun)] -> Box -> Maybe Bool

-- | Decide a conjunction in a best-first manner using a priority queue.
--   Maximal minimums over conjunctions are used to order them, with larger
--   maximal minimums taking priority.
decideConjunctionBestFirst :: MaxPQueue (CN MPBall) ([(ESafe, BoxFun)], TypedVarMap, Bool) -> Integer -> Integer -> Rational -> Precision -> (Maybe Bool, Maybe TypedVarMap)

-- | Decide a conjunction arising from a DNF over a given box using a
--   depth-first branch-and-prune algorithm which tends to work well when
--   the problem is unsatisfiable.
decideConjunctionDepthFirstWithSimplex :: [(ESafe, BoxFun)] -> TypedVarMap -> TypedVarMap -> Integer -> Integer -> Rational -> Precision -> (Maybe Bool, Maybe TypedVarMap)

-- | Decide a conjunction arising from a DNF over a given box using a
--   best-first branch-and-prune algorithm which tends to work well when
--   the problem is satisfiable.
decideConjunctionWithSimplexCE :: [(ESafe, BoxFun)] -> TypedVarMap -> TypedVarMap -> Rational -> Precision -> Bool -> (Maybe Bool, Maybe TypedVarMap, [(ESafe, BoxFun)], Bool)
